package psql

import (
	"database/sql"
	"fmt"
	"log"
)

type Model struct {
	DB *sql.DB
}

type Thought struct {
	ID    int    `db:"id"`
	Title string `db:"Title"`
	Text  string `db:"Content"`
}

func NewDbConnection(host, port, user, password, dbname string) (*Model, error) {
	psqlInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", host, port, user, password, dbname)

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		return nil, err
	}

	err = db.Ping()
	if err != nil {
		return nil, err
	}
	return &Model{DB: db}, nil
}

func (m *Model) Insert(Title string, Content string) error {
	stmt := `INSERT INTO Blog (Title, Content)
	VALUES ($1, $2);`
	_, err := m.DB.Exec(stmt, Title, Content)
	if err != nil {
		return err
	}
	return nil
}

func (m *Model) CreateTable() error {
	stmt := `CREATE TABLE IF NOT EXISTS Blog (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Title varchar(50) NOT NULL ,
    Content text
    );`
	_, err := m.DB.Exec(stmt)
	if err != nil {
		return err
	}
	return nil
}

func (m *Model) GetThoughts(limit, offset int) ([]Thought, error) {
	query := fmt.Sprintf(`SELECT id, title, content FROM Blog ORDER BY id LIMIT %d OFFSET %d`, limit, offset)
	rows, err := m.DB.Query(query)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	thoughts := make([]Thought, 0, 3)
	for rows.Next() {
		v := Thought{}

		rows.Scan(&v.ID, &v.Title, &v.Text)
		thoughts = append(thoughts, v)
	}
	return thoughts, nil
}

func (m *Model) GetCountOfThoughts() int {
	query := "SELECT count(*) FROM blog"
	var total int

	err := m.DB.QueryRow(query).Scan(&total)
	if err != nil {
		log.Fatalln(err)
	}

	return total
}
